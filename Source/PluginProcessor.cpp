/*
 ==============================================================================
 
 This file was auto-generated by the Introjucer!
 
 It contains the basic framework code for a JUCE plugin processor.
 
 ==============================================================================
 */

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
HierarchicalShiftAudioProcessor::HierarchicalShiftAudioProcessor():
recordHead(0),
playHead(0),
localBpm(60),
localLoopBeats(4)
{
    setPlaying(false);
    generateLinearBeatMap(true);
    //    generateRandomBeatMap(localLoopBeats);
}

HierarchicalShiftAudioProcessor::~HierarchicalShiftAudioProcessor()
{
}

//==============================================================================
void HierarchicalShiftAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    minBufAhead = getSampleRate();
    prepareRecordBuffer();
}

void HierarchicalShiftAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void HierarchicalShiftAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    
    
    
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    
    checkBufferLength();
    updatePosition();
    
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    
    switch (recordState){
        case RECORDING :
            recordNext(buffer);
            break;
            
        case PLAYING :
            playNext(buffer);
            break;
            
            
        case STOPPED :
            //            buffer.clear();
            break;
            
        default:
            jassert(false);
            break;
            
            
            
    }
    
    
    
}

void HierarchicalShiftAudioProcessor::recordNext(AudioSampleBuffer& b){
    
    if(recordBPM!=position.bpm){
        DBG("cant change BPM while recording");
        jassertfalse;
    }
    localBuffer.copyFrom(0, recordHead, b, 0, 0, b.getNumSamples());
    recordHead+= b.getNumSamples();
}

void HierarchicalShiftAudioProcessor::checkBufferLength(){
    int64 length = localBuffer.getNumSamples();
    switch (recordState){
        case RECORDING :
            
            if((length-recordHead) < minBufAhead){
                localBuffer.setSize(1, length + minBufAhead ,true);
            }
            break;
            
        case PLAYING :
            break;
            
        case STOPPED :
            break;
            
            
    }
}




void HierarchicalShiftAudioProcessor::setRecording(bool b){
    if(b){
        recordHead = 0 ;
        startRecordPosition = position.timeInSamples;
        DBG("recordPos" << String(startRecordPosition));
        recordState = RECORDING;
        recordBPM = position.bpm;
        prepareRecordBuffer();
        
    }
    else{
        setPlaying(true);
    }
}
void HierarchicalShiftAudioProcessor::setPlaying(bool b){
    if(b){
        recordState = PLAYING;
        playHead=0;
        
        if(hasTransportInfo){
            int64 numRecordedBeats = sampleToBeat((position.timeInSamples - startRecordPosition));
            localLoopBeats = ((int)numRecordedBeats) - ((int)numRecordedBeats)%4;
            int64 newSize = BeatToSample(localLoopBeats);
            DBG("resizing buffer to" << String(newSize) << " : " << String(newSize/getSampleRate()));
            localBuffer.setSize(1, newSize,true);
            
        }
        
        //infer bpm from loop duration and expected n of beats
        else{
            int64 loopLength = (position.timeInSamples - startRecordPosition);
            localBpm = localLoopBeats*60.0*getSampleRate()/loopLength;
            recordBPM = localBpm;
            localBuffer.setSize(1, loopLength,true);
        }
        
        //        int64 crossfadeSamples = getSampleRate()*0.01;
        //        localBuffer.applyGainRamp(0,0, crossfadeSamples, 0, 1);
        //        localBuffer.applyGainRamp(0, localBuffer.getNumSamples() - crossfadeSamples - 1, crossfadeSamples, 1, 0);
        
    }
    else{
        recordState =STOPPED;
    }
}


void HierarchicalShiftAudioProcessor::prepareRecordBuffer(){
    localBuffer.setSize(1, 3*getSampleRate());
}




void HierarchicalShiftAudioProcessor::updatePosition(){
    
    juce::AudioPlayHead::CurrentPositionInfo p;
    
    getPlayHead()->getCurrentPosition(p);
    
    
    
    // for non bpm host (juce audio host)
    if(p.bpm == 0 ){
        hasTransportInfo = false;
        position.bpm = localBpm;
        
        
        if(position.timeInSamples<0){
            position.timeInSamples = 0;
        }
        position.timeInSamples +=getBlockSize();
        
        
    }
    else{
        hasTransportInfo=true;
        position = p;
    }
    
    
}

int64 HierarchicalShiftAudioProcessor::BeatToSample(double b,bool originBPM ){
    return b*getSampleRate()*60.0/(originBPM?recordBPM:position.bpm);
}
double HierarchicalShiftAudioProcessor::sampleToBeat(int64 h,bool originBPM ){
    return h*(originBPM?recordBPM:position.bpm)/(60.0*getSampleRate());
}


void HierarchicalShiftAudioProcessor::playNext(AudioSampleBuffer& b){
    
    double startFrom = sampleToBeat(position.timeInSamples - startRecordPosition);
    double endAt = sampleToBeat(position.timeInSamples - startRecordPosition+ b.getNumSamples());
    
    jassert(sampleToBeat(b.getNumSamples())<1);
    
    // beat change handles ends of loop
    if( (int) endAt- (int)startFrom >=  1){
        jassert((int) endAt- (int)startFrom == 1);
        int start = getBeatsMappedIndex(startFrom);
        double size1 = ((int)startFrom+1)-startFrom ;
        int start2 = getBeatsMappedIndex((int)(startFrom+1));
        double size2 = endAt - ((int) startFrom+1);
        //
        
        
        // TODO : do we need to round errors?
        //        int error = b.getNumSamples() -(BeatToSample(size1) + BeatToSample(size2));
        //        if(error!=0){
        //            size1+=sampleToBeat(error);
        //            // big round off isn't it?
        //            if(std::abs(error)>2){
        //                DBG(start << "," << BeatToSample(size1)<<","<< start2 << "," << BeatToSample(size2));
        //                jassertfalse;
        //            }
        //        }
        
        for (int channel = 0; channel < getNumOutputChannels(); ++channel)
        {
            b.copyFrom(channel, 0, localBuffer, 0, start,BeatToSample(size1) );
            b.copyFrom(channel, BeatToSample(size1), localBuffer, 0, start2,BeatToSample(size2) );
            
        }
        
        
    }
    else{
        int64 start = getBeatsMappedIndex(startFrom);
        int64 size1 = b.getNumSamples();
        for (int channel = 0; channel < getNumOutputChannels(); ++channel)
        {
            b.copyFrom(channel, 0, localBuffer, 0, start,size1 );
        }
        //        DBG(start << " , " << size1);
        
    }
    
    
    
    playHead+= b.getNumSamples();
    
    
}


void HierarchicalShiftAudioProcessor::setNumBeats(int num){
    localLoopBeats = num;
    int oldSize = beatMap.size();
    beatMap.resize(localLoopBeats);
    // retrieve or zero pad if added
    for(int i = oldSize ; i < localLoopBeats ; i++){
        if(i<longestBeatMap.size())
            beatMap.set(i,std::min((int)localLoopBeats-1,longestBeatMap[i]));
        else
            beatMap.set(i,0);
    }
}


int64 HierarchicalShiftAudioProcessor::getBeatsMappedIndex(double b){
    int loopLength = beatMap.size();
    
    
    int beatNum = ((int)b % loopLength);
    //    jassert(((int)b)<loopLength);
    int64 beatSize = getSampleRate()*60/recordBPM;
    //    int64 beatSize = localBuffer.getNumSamples()/loopLength;
    int64 curBeat = (beatMap[beatNum] + (b - (int)b) ) * beatSize ;
    
    if(curBeat>= localBuffer.getNumSamples()){
        DBG(curBeat <<" , " << localBuffer.getNumSamples());
        jassert(false);
    }
    
    return curBeat;
    
    
}

void HierarchicalShiftAudioProcessor::generateRandomBeatMap(){
    int size = localLoopBeats;
    beatMap.resize(size);
    Array<int> toMap;
    toMap.resize(size);
    Random random = Random();
    toMap.set(0,2);
    for(int i = 1 ; i < size ; i++){
        toMap.set(i, i);
    }
    
    
    for(int i = size-1 ; i >=0  ; i--){
        int nIdx = random.nextInt(size);
        beatMap.set(i,toMap[nIdx]);
        toMap.remove(nIdx);
    }
    
    
    longestBeatMap=beatMap;
}

void HierarchicalShiftAudioProcessor::generateLinearBeatMap(bool reversed){
    int size = localLoopBeats;
    beatMap.resize(size);
    for(int i = 0 ; i < size ; i++){
        beatMap.set(i, reversed?size-1-i:i);
    }
        longestBeatMap=beatMap;
}



AudioProcessorEditor* HierarchicalShiftAudioProcessor::createEditor()
{
    return new HierarchicalShiftAudioProcessorEditor (*this);
}

//==============================================================================
void HierarchicalShiftAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void HierarchicalShiftAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

bool HierarchicalShiftAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double HierarchicalShiftAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int HierarchicalShiftAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int HierarchicalShiftAudioProcessor::getCurrentProgram()
{
    return 0;
}

void HierarchicalShiftAudioProcessor::setCurrentProgram (int index)
{
}

const String HierarchicalShiftAudioProcessor::getProgramName (int index)
{
    return String();
}

void HierarchicalShiftAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
const String HierarchicalShiftAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int HierarchicalShiftAudioProcessor::getNumParameters()
{
    return 0;
}

float HierarchicalShiftAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void HierarchicalShiftAudioProcessor::setParameter (int index, float newValue)
{
}

const String HierarchicalShiftAudioProcessor::getParameterName (int index)
{
    return String();
}

const String HierarchicalShiftAudioProcessor::getParameterText (int index)
{
    return String();
}

const String HierarchicalShiftAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String HierarchicalShiftAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool HierarchicalShiftAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool HierarchicalShiftAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool HierarchicalShiftAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool HierarchicalShiftAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}



//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new HierarchicalShiftAudioProcessor();
}

